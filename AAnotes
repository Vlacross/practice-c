overall great resource for C and other things (similar to geeks for geeks)
    https://www.studytonight.com/library/

List of C programs for practice
    https://www.studytonight.com/c/programs/



Completed Basic C-Programs: {
    Hello-world: simpleWorld2.c,
    Takin-input-from-user: taking_input.c,
    Find-ASCII-value: ascii_val.c,
    Using-gets()-function: gets.c,
    If-Else: if-else.c,
    Switch-Case: vowel_find.c,
    Checking-for-vowel: vowel_find.c,
    Reversing-Case-of-Char: reverseCase.c,

}

Completed C-Guide-Lessons: {
    1: "Overview of C Language",
    2: "Features of C",
    3: "",
}


Guide NOTES:
1- C is good starting language and is fast to compile and run.

2- C features :
    variety of datatypes
    fast & efficient
    portable
    easy to extend
    Modularity
    rich libraries

3- Parts of C program: {
    Pre-processor: "links header files; houses macros",
    Header-File: "Collection of builtin/ready-made functions; basic .h file is stdio.h",
    Function: " 'main()' function is body of each program; return type specified before declaration (ie: int main() {...; return 0})",
    Variables: "defined keywords used to handle values and behaviors",
    Statements-&-Expressions: "Statement are expression and more. They do things(ie: assingment); Expressions return something using defined computation",
    Comments: "single line comments started with '//' or multi-line comments surrounded with '/* ... */'"
}

4- Compile and Run C Program:
    run :
        cat > hello.c << EOF
            #include<stdio.h>
            int main()
            {
                printf("\nHello World!\n");
                exit 0;
            }
            EOF
    then run:
        gcc -o helloWorld hello.c
    
    Run program:
        ./helloWorld

5- C Language Basic Syntax Rules:
    How C-Language is specified/recognized is based on C "tokens"
        ie: the tokens of the line "printf("hello, World");"
        are: 'printf', '(', '"Hello, World"', ')', and ';' 

    Semicolon is used to mark the end of each line. If this is missing the compiler will throw an error.

    Comment symbols '//' & '/* */' are recognized by the compiler as text to not be compiled

    tips:
        c is case sensitive
        all c statements must end with a Semicolon
        whitespace is used to describe blanks and tabs
        whitespace is required between keywords and identifiers.

    Example structure:
        #include<stdio.h>
        int main()
        {
            printf("\nHello, you simple World.\n") ;
        }

6-  C Keywords:
        auto        double        int       struct
        break       else          long      Switch
        case        enum          register  typedef
        const       extern        return    union
        char        float         short     unsigned
        continue    for           signed    volatile
        default     goto          sizeof    void
        do          if            static    while

    C Identifiers - names given to constants/variables, functions, and user-data.
        -Can only have alphanumeric cshort hars and underscores (a-z)(A-Z)(_);
        -First char can only be a letter/alphebetic char;
        -Are case sensitive;
        -Cannot be a C Keyword;
        -Cannot conatin special chars;
    Example declaration:
        int customVar = "Some String";

    C Charsets:
        Letters(all alphebetic chars);
        Digits(0-9);
        Special chars(colon, semi-colon, period, underscore, ampersand, ...);
        White spaces

7-  Operators in C:
        -Arithmetic;
        -Relational;
        -Logical;
        -Bitwise;
        -Assignment;
        -Conditional;
        -Special;

        1) Arithmetic:
            [ +, -, *, /, %, ++, -- ];
        
        2) Relational:
            [ ==, !=, >, <, >=, <= ];
        3) Logical:
            [ &&, ||, ! ]
        4) Bitwise:
            [ &, |, ^, <<, >> ];

            Truth table for Bitwise &, |, and ^:
            a       b       a&b     a|b     a^b
            0       0       0       0       0
            0       1       0       1       1
            1       0       0       1       1
            1       1       1       1       0

            Shift Operator example:
                a =      0001000;
                b =      2;
                a << b = 0100000;
                a >> b = 0000010;

        5) Assignment:
            [ =, +=, -=, *=, /=, %= ];

        6) Conditional:
            [ ? : ];        /*<-- intentionally no comma between symbols. */
            
            Example Ternary:
                (expression or booleanVariable) ? "this is what returns if expression is true" : "this is what returns if expression is false";

        7) Special:
            [ sizeof, &, * ];
            sizeofe     returns the size of a variable;         sizeof(x) returns size of variable "x";
            &           returns the address of a variable;      &x; returns the address of variable "x";
            *           pointer to variable;                    *x; will be a pointer to variable "x";
            
8-  Data types in C:
    https://www.studytonight.com/c/datatype-in-c.php
    https://userweb.cs.txstate.edu/~js236/201112/cs1428/lecture3.pdf

        Data types are broken down into two types:
            1)Primary data types: fundamental data types - int, float, char, and void
            2)Derived data types: Primary datatypes twisted or grouped -- array, structure, union, and pointer

                                    Primary Data Type
        Character                   Interger                    float               Void
            char                signed      unsigned                float

            Signed char         int         int                     double

            Unsigned char       short int   short int               long double

                                long int    long int
        

        Type                                size                            Range
        
        Integer
            int or signed int               2                               -32,768 - 32,767
            unsigned int                    2                               0 - 65535
            short int /unsigned short int   1                               -128 - 127
            unsigned short int              1                               0 - 255
            long int/signed long in         4                               -2,147,483,648 - 2,147,483,647
            unsigneed long int              4                               0 - 4,294,967,295
        Floating
            Floating                        4                               3.4E-38  -  3.4E+38
            double                          8                               1.7E-308  -  1.7E+308
            long double                     10                               3.4E-4932 - 1.1E+4932
        Character
            char or signed char             1                               -128 - 127
            unsigned char                   1                               0 - 255
        Void
            void - means no value. Used to specify functions that return nothing.

        (NOTE: 
            e/E is often used in place of scientific notation
            e- is the inverted (divide by 10 instead of multiply by 10)
                1.7E+3 is the same as 1.7 * 10^3 == 1700
                +3.4e38 == 34000...000 (with 37 zeros)
                -3.4e-38 == .34000...000 (with 37 zeros)
                +3.4e38 == .000...034 (with 37 zeros)
                -3.4e38 == -.000...034 (with 37 zeros)
            Mantissa - The part of a logarithm that follows the decimal point (any digits to the right of the decimal)
                If 0.12345678901234567 is stored in a type float (which can store about 7 digits in its mantissa), it will get rounded to 0.1234568
                A type double can store about 15 digits in the mantissa, so it would be rounded to 0.1234567890123456 

        )

9-  Variables in C Language
        https://www.studytonight.com/c/variables-in-c.php
        
        Variable - a named memory location
            -unlike constants, variables can change/can be changed during execution of a program.
        
        variables in C need to be given a type to define what datatype it will hold. This can be:
            char - Can hold a a Character
            int - holds an integer
            float - holds a float value
            double - holds a double value
            void

        variable names can:
            not start with a digit
            consist of alphebets, digits, and special symbols like underscore
            not include blank or white space
            not be a keywords
            use upper and lower cases of letters, but is case-sensitive

        declaration of variables must be done before they are used.
            it tells the compiler what the variable name is
            it specifies what type of data the variable will hold
            until the variable is defined, the compiler doesn't have to worry about allocating memory space to it
            declaration is more like informing the compiler that there exists a variable with the foloowing datatype which is used in this program
            a variable is declared using the 'extern' keyword, outside the `main()` function.
                extern int a;
                extern float b;
            
        Defining a variable means the compiler has to now assign a storage to the variable because it will be used in the program. 
            It is not necessary to declare a variable using the `extern` keyword if you want to use it in your program. 
            You can directly define a variable inside the `main()` function and use it.

            To define a var inside a function you must define the datatype and the variable name. You can define multiple vars of same datatype 
                in a single line by using a comma seperated list:
                    int a;
                    float b, c;
            
        Initializing a variable means to provide it with a value. Can be initialized and defined in a single statement:
            int a = 10;

        Identifyer - a name given to any function, variable, structure, pointer, or other entity in a programming language.
            can be a variable, but not all identifiers are

        Variable - a named memory location used in the program.

10- C Input and Output
    https://www.studytonight.com/c/c-input-output-function.php

    Basic input-output header file is stdio.h - contains printf() and scanf()

        Using %d, %f, %c, %s inside scanf() captures user input, followed by the &<variable> to initialize the variable to the input value:
            int num;
            scanf("%d", &num);

        printf() function returns the number of characters printed by it
        scanf() returns the number of characters read by it:
        
                int i = printf("studytonight");
            will return 12 as the result which will be stored in the variable i.


        gets() funciton reads a line from stdin() into the buffer pointed to by "str" pointer, until either a terminating 
            newline of EOF occurs.
        puts() function writes the string "str" and a trailing newline to stdout
        ```
            #include<stdio.h>
            {
                char str[100];
                printf("Enter a string");
                gets( str );
                puts( str );
                getch();
            }
        ```
        when compiled, the above will request a string and then print the value entered.

        Difference between scanf() and gets() is that scanf() stops reading characters when it encounters a space, but gets() reads 
        space as a character too.
            
11- Decision making in C ( if, switch, goto )
    https://www.studytonight.com/c/decision-making-in-c.php

    Decision making is about deciding the order of execution of statements based on conditions, or repeating a group of statements 
        until certain condiftions are met. In C, this is handled with:

    -if Statements
    -switch statements
    -conditional operators ? :
    -goto statement

    If statements:
        1) simple if statemtents
            if(expression)
            {
                statement inside;
            }
                statement outside;
        2) if...else statement
            if(exor)
            {
                statement block1;
            }
            else{
                statement block2;
            }
        3) Nested if....else
            if(expr1)
            {
                if(expr2)
                {
                    nested statement;
                }
                else
                {
                    nested else statement;
                }
            }
            else
            {
                un-nested statement;
            }
        4) using else if ladder
            if(expr1)
            {
                statement1;
            }
            else if(expr2)
            {
                statement 2;
            }
            else
            {
                default statement;
            }

    Notes - 
    -curly braces are not required if there is only one statement outside the if condition.
        example :
            int a = 5;
            if(a > 4)
                printf("yep!");
     -"==" must be used to compare as "=" assigns and comes back as true
     -other than 0, all other values return as true:
        if(27)
            print("hello")
        ^ prints true ^   

-12 Switch statement in C:
    https://www.studytonight.com/c/switch-statement-in-c.php
    
    Example syntax:
        switch(expression)
        {
            case value-1:
                block-1;
                break;
            case value-2:
                block-2;
                break;
            case value-3:
                block-3;
                break;
        }

    -The expression must be an integer value (either be an integer or an expression that evaluates to an integer)
    -Each case "label" must be unique ( i.e.: value-2 ) And end in a colon
    -line following the case statement can be any valid C statement.
    -if "break" is not specified, the block will continue to run through every case:
        int i = 1;
        switch(i)
        {
            case 1:
                printf("A");
            case 2:
                printf("B");
            case 3:
                printf("C");
                break;
        }

        ^This yields output: "A B C" since case 1 matches but there is no break until case 3

    -Nested switch cases are possible but not recommended due to their effect of increasing complexity of compiled

    NOTE: 'if' statements can evaluate 'float' conditions, whereas switch statements cannot.
           'if' statements can evaluate relational operators which are not allowed in switch statements.

-13 Looping
    https://www.studytonight.com/c/loops-in-c.php

    Loops are instruction sets that specify a condition, that if the value given to the condition is either true/false, 
        will either rerun until the given condition is met or break from the loop depending on what kind of loop / what the conditions are.

    Types of Loops:
        while
            While specified condition is true, continue loop and break once condition is unmet.
            Ex:
                #include<stdio.h>

                void main()
                {
                    int x;
                    x = 1;
                    while(x <= 10)
                    {
                        printf("%d\t", x);
                        x++;
                    }
                }
        for
            Used to iterate across a range (such as an array etc)
            Instructions(held within parens and seperated by semi-colons) state a starting value(what will be tested against the condition), ending
             value (what condition must be matched), anda step/increment/change (a mutation applied to the starting value before each testing 
             against the condition)
            Ex:
                #include<stdio.h>

                void main()
                {
                    int x;
                    for(x=1; x <= 10; x++)
                    {
                        printf("%d\t", x);
                    }
                }
            for loops can be nested inside each other. 
            Ex: (builds a "half pyramid")
                int i, j;

                for(i=1; i <= 5; i++)
                {
                    printf("\n);

                    for(j=i; j > 0; j--)
                    {
                        printf("%d", j);
                    }
                }
        do while
            Same as a while loop, but executes code-block before checking condition.
            Ex(general syntax):
                #include<stdio.h>

                void main()
                {
                    int a, j;
                    a = 5;
                    j = 1;

                    do
                    {
                        printf("%d\t", a*j);
                        j++;
                    }
                    while(j <= 32);
                }
        Jumping out of loops
            break - adding an inner condition with a break will immediately exit the loop once the inner condition is met

            continue - adding an inner condition with a continue immediately skips the rest of the code block and starts into the next interation.

- 14 Arrays in C
    https://www.studytonight.com/c/arrays-in-c.php

    arrays are structured data types - "Finite ordered collection of homogenous data" stored in contiguous memory locations.
        finite - data range must be defined
        ordered - data must be stored in a continuous memory address
        homogenous - data must be of similar data type
            Other structures in c are :
                structure
                lists
                queue
                trees
                etc

    Declaring an array:
        Syntax = <data-type> <variable-name>[size]

        example -- int arr[10];
        outputs: [0][1][2][3][4][5][6][7][8][9][10]
            where each number in the index/location within the array

    Initialization of an Array:
        int marks[4]={ 67, 87, 55, 77 };

        float area[5]={ 23.4, 6.9, 5.5 };

        int marks[4]={ 44, 55, 22 ,33, 7 }  // This creates a compile time error as it is adding more items than memory is allocated

            #include<stdio.h>

            void main()
            {
                int i;
                int arr[]= { 2, 3, 4 };
                for(i=0; i < 3; i++)
                {
                    printf("%d", arr[i]);
                }
            }

        Initializing arrays at runtime using scanf can be used for large arrays or when using user specified values:

            #include<stdio.h>

            void main()
            {
                int arr[4];
                int i, j;
                printf("Enter Array element");
                for(i=0; i < 4; i++)
                {
                    scanf("%d", &arr[i]);
                }
                for(j=0; j < 4; j++)
                {
                    printf("%d\n", arr[j]);
                }
            }

        Two Dimensional Arrays:
            Sytnax = <data-type> <arr-name> [row-size][column-size]

            int a[3][4]:
                    [0[0]]    [0][1]      [0][2]
                    [1[0]]    [1][1]      [1][2]
                    [2[0]]    [2][1]      [2][2]

        Or as -
            int arr[][3] = {
                { 0, 1, 2 },
                { 3, 2, 1 }
            };
            **Without speficying any row-number(the empty square-bracket) it means we can initialize any number of rows, but they must
                follow the size specified for columns if it is set.
                
            #include<stdio.h>

            void main()
            {
                in arr[3][4];
                int i, j;
                printf("Enter array element");
                for(i=0; i < 3; i++)
                {
                    for(j=0; j < 4; j++)
                    {
                        scanf("%d", &arr[i][j]);
                    }
                }
                for(i = 0; i < 4; i++)
                {
                    for(j=0; j < 4; j++)
                    {
                        printf("%d", arr[i][j]);
                    }
                }
            }

- 15 String and Character Array 
    https://www.studytonight.com/c/string-and-character-array.php

    In C, a String is a one-dimensional array of characters that is treated as a single data item and is terminated by the null character 
        "\0" automatically added by the compiler.
        -Valid initializations - char name[13] = "StudyTonight";   
                                char name[10] = {'L', 'e', 's', 's', 'o', 'n', 's', '\0'}; 
                            /*In the first example: if it was 12 instead of 13, this would be invalid - it needs space for the newline char*/ 
    
        -Invalid initializaiont - char ch[3] = "hell";                  /* "hell" would require at least 5 for allotted memory for the null char */

        -scanf() can be used with %s to read a string from input, but ends reading at any whitespace, so "hello world" would only read "hello";
        -However, C supports a format spec known asd the `edit set conversion code %[..]` that can be used to read a line containing a variety of 
            chars+whitespaces:
            Example:
                #include<stdio.h>
                #include<string.h>

                void mand()
                {
                    char str[20];
                    printf("Enter a string:");
                    scanf("%[^\n]", &str);
                    printf("%s", str);
                }
        Another method is with the gets() function:
                char text[20];
                gets(text);
                printf("%s", text);

    C has a number of string handling functions, many of which are included in the `string.h` library. Common ones are:
        strcat() - used to concatenate(combine) two strings;
            strcat("simple", "world")
        strlen() - shows the length of the str;
            int j;
            j - strlen("studytonight");
            prinf("%d", j);
        strrev() - used to show the revese of a string;
            #include<stdio.h>

            int main()
            {
                char s1[50];
                printf("Enter your string:");
                gets(s1);
                printf("\nYour recerse string is: %s", strrev(s1));
                return(0);
            }

        strcpy() - copies one string into another;
            #include<stdio.h>
            #include<string.h>

            int main()
            {
                char s1[50];
                char s2[50];

                strcpy(s1, "StoopsGalore");
                strcpy(s2, s1);

                printf("%s\n", s2);
                return(0);
            }
        strcmp() - used to compare two strings; will return the ASCII differnce between first unmatching char or two strings:
            int j;
            j = strcmp("Stoops", "Galore");
            printf("%d", j);

- 16 Storage classes in C
    https://www.studytonight.com/c/storage-classes-in-c.php

    In C, each variable has a storage class which decides:
        -Scope (where it is available)
        -DIV (Default Initial value)
        -Lifetime (how long the variable will exist)

    Commone Storage Classes:

        -Automatic (aka Local) Variables: 'auto'
            Scope: 'auto' storage class are local to the function block where they are defined;
            DIV: Any random value (i.e. garbage value)
            Lifetime: 'auto' storage class lasts until the end of the function/method where the variable is defined

            **A variable declared inside a function without any storage class specification is by default an AUTOMATIC VARIABLE. 
                They are created when a function is called and are destroyed AUTOMATICALLY when the functions completes it's execution. 
                Auto variables can also be called LOCAL VARIABLES because they are local to a function. By default they are assigned 
                a GARBAGE VALUE by the compiler.
                #include<stdio.h> 

                void main()
                {
                    int detail;
                    /* same as: */
                    auto int details;
                }

        -External (aka Global) Variables: 'global'
            Scope: Global/ everywhere in the program. Not bound by any scope;
            DIV: 0(zero);
            Lifetime: Until the end of a program's execution. 

            **Globals are declared outside any function. Their value can be changed by any function in the program;
                #include<stdio.h>

                void main()
                {
                    number = 10;
                    printf("I'm in the main function. My value is %d\n", number);
                    fun1();
                    fun2();
                }

                fun1()
                {
                    number = 20;
                    printf("I am the first function and my value is %d\n", number);
                }

                fun2()
                {
                    printf("\nI am the second function and my value is %d\n", number);
                }

        -Extern Keyword: (extern)
            the 'extern' keyword is used with a variable to inform the compiler that this variable is declared somewhere 
                else in the program. The 'extern' declaration does not allocate storage for variables.
                            file1.c                               file2.c
                    ------------------------                ------------------------
                    #include<stdio.h>                          #include<stdio.h>
                    int a = 7;  #-------------                 main()
                    void fun()                --
                    {                           --             {
                        a++;                      ------->          extern int a;
                        printf("%d", a);                            fun();
                        ......
                    }                                           }
                                */ The above shows a global 'int a' can be used in file 2 with the 'extern' keyword /*
                                */ without 'extern' results in "Error: cannot find definition of a variable 'a' " /*
                    /* Example of using 'extern' in same file */
                    int main()
                    {
                        extern in x;
                        x = 10;
                        printf("%d", x);
                    }
                    int x;

        -Static Variables: (static)
            Scope: Local to the block in which the variable is defined;
            DIV: 0(zero);
            Lifetime: Until the end of the program's execution;

            **A static variable lasts until the end of the program, but can be internally or externally scoped depending
                on where they are declared. The scope of the variable remains inside the funciton in which it is defined.
                External static veriables remain restricted to the scope of the file in which they are declared.

                #include<stdio.h>

                void test() /* function declaration which is discussed in next section */

                int main()
                {
                    test();
                    test();
                    test();
                }

                void test()
                {
                    static int a=0;
                    a = a+1;
                    printf("%d\t", a);
                }  /* Output: 1     2     3 */
                

        -Register Variables: (register)
            Scope: Local to the function in which it is declared;
            DIV: and random value ( i.e.: garbage value);
            Lifetime: Until the end of the function block;
            **Register variables inform the compiler to store the variable in CPU register instead of memory. Register vars
                have faster accessibility than normal vars. Generally used for frequently used cars - but only a few vars can
                be placed inside registers. Example use case is in using loops, where the var is used a number of times in a 
                very short time span.
                        `register int number`;
                ***The number of registersw in a CPU are limited, so they may not always be free which means that even though you
                    declare them as a 'register', they may not be stored in a register. In this event, the variable works as if 
                    its storage class is 'auto';

        -Which storage class should be used when:
            -Use 'static' onle when you want the value of the variable to remain the same every time you call it using different 
                function calls;
            -Use 'register' only for variables that are used in you program very often. CPU registers are limited and thus should
                be used carefully;
            -Use 'external' or 'global' only for vars that are beingused by almost all the functions in the program;
            -If you don't have the purpose for using any of the above storage classes, use 'auto';


- 17 Functions in C
    https://www.studytonight.com/c/user-defined-functions-in-c.php

    A function is a set of instructions designed to perform a patricular task.

    A function can either be:
        - Library Function
            pre-defined in C library (ex: printf(), scanf(), strcat()). As long as the proper header file is included in the file,
            these functions are available without needing to be written/defined by the user.
        - User-defined Function:
            Custom action / algorithm used for code reusability and for saving time and space.

    Functions provide modularity, makes code reusable, allows custom tooling which can help in debugging (especially in 
      multi-thousand line code), and it makes the program more readable.

    Like variables, Functions must be declared before they can be used.

    Function Declaration::

    General syntax for function declaration:

                                        |         Parameter List        |       terminating semi-colon
        <return-type> <functionName>(<type1 parameter1, type2 parameter2, ...>);

        - <return-type>:
            When a function is declared to perform some calculation or operation and is expected to provide a result, a return 
            statement is added to the end of the func body. the return-type specifies the returned value (int, float, char, double)
          *If your function doesn't return any value, the return type would be 'void'

        - <functionName>:
            The function name is an identifier and must follow the same naming conventions as any other variable.

        - <parameter-list>:
            Parameter list declares the type and number of arguments that the function expects. It also receives the arguments values 
            when the function is called. They are often called "Formal Parameters".

        Example:

            #include<stdio.h>

            int multiply(int a, int b);

            int main()
            {
                int i, j, result;Declaration
                printf("Please enter 2 numbers you want to multiply: ");
                scanf("%d%d", &i, &j);

                result = multiply(i, j);

                printf("The result of multiplication is : %d", result);

                return 0;
            } 

            int multiply(int a, int b)
            {
                return (a*b);
            }
        

    Function Definition::

    General syntax for function Definition:

        |               First line (below) is called the header                |
        <return-type> <functionName>(<type1 parameter1, type2 parameter2, ...>);
        {
            <function-body>
        }

    Note : when DEFINING a func, there is no semicolo after the parenthesis.

    - <function-body>:
        The function body consists of three parts:
            - local variable declaration (if needed)
            - function statements to perform the task(s) inside the function
            - a return statement to return the result evaluated by the function (unless return type 'void')


    When a function is called, control of a program gets transfered to the function.

    Arguments are the values specified during the function call. for which the formal parameters are declared
     while defining the dunction.

        It is possible to have a function with parameters but no return type. It is not necessary that if
         a function accepts parameter(s), it must return a result too. 

        If a function is declared with 2 parametes (int a, int b), It must be passed 2 arguments when it is called 
         else it will throw a compilation error. The two arguments passed should be received in the function definition,
          which means that the function header in the definition should have two parameters to hold the argument values.

    Returning a value from a function:
        A function may or may not return a result, but if it does, it must contain a 'return' statement.
        the 'return' statement ends the function execution, so it must be the last statement in any function. Anything
        written after the return statement won't be executed.

        The Datatype returned from a function must match that of which it was declared, else a compilation error will result.

- 18 Types of User-defined Functions in C
    https://www.studytonight.com/c/type-of-functions-and-recursion.php

    4 types of user-defined functions are:
        1) Function with no args and no return val
        2) Function with no ars and a return val
        3) Function with args and no return
        4) Function with args and a return val

        1) Function with no args and no return val:
            Either used to display info or are completely dependant upon user input:
            Example:

            #include<stdio.h>

            void greatNum();

            int main()
            {
                greatNum());
                return 0;
            }

            void greatNum()
            {
                int i, j;
                printf("Enter 2 numbers that you want to compare...");
                scanf("%d%d", &i, &j);
                if(i < j) {
                    printf("The greater number is: %d", i);
                }
                else {
                    printf("The greater number is: %d", j);
                }
            }


        2) Function with no ars and a return val
            Modified above to have greatNum function return the greater of the input numbers:

            #include<stdio.h>

            int greatNum();

            int main()
            {
                int result;
                result = greatNum();
                printf("The greater number is: %d", result);
                return 0;
            }

            int greatNum()
            {
                int i, j;
                printf("Enter 2 numbers to compare:");
                scanf("%d%d", &i, &j);
                if(i > j) {
                    greaterNum = i;
                }
                else {
                    greaterNum = j;
                }
                return greaterNum;
            }


        3) Function with args and no return
            #include<stdio.h>

            void greatNum(int a, int b);

            int main()
            {
                int i, j;
                printf("Enter 2 numbers that you want to compare...");
                scanf("%d%d", &i, &j);
                greatNum(i, j));
                return 0;
            }

            void greatNum(int x, ing y)
            {
                if(x < y) {
                    printf("The greater number is: %d", y);
                }
                else {
                    printf("The greater number is: %d", x);
                }
            }


        4) Function with args and a return val
            #include<stdio.h>

            void greatNum(int a, int b);

            int main()
            {
                int i, j, result;
                printf("Enter 2 numbers that you want to compare...");
                scanf("%d%d", &i, &j);
                result = greatNum(i, j));
                printf("The greater number is: %d", result);
                return 0;
            }

            void greatNum(int x, ing y)
            {
                if(x < y) {
                    return y
                }
                else {
                    return y;
                }
            }

    Nested functions are functions inside of other functions.

    Recusive functions are functions that can/do call themselves inside.

    Recusive Function Example:
        #include<stdio.h>

        int factorial(int x);

        void main()
        {
            int a, b;

            printf("Enter a number:");
            scanf("%d", &d);
            b = factorial(a);
            printf("%d", b);
        }

        int factorial(int x)
        {
            int r = 1;
            if(x == 1)
                return 1;
            else
                r = x*factorial(x-1);

            return r;
        }



- 19 Types of Function Calls in C
    https://www.studytonight.com/c/types-of-function-calls.php

    Functions can be called in two different ways:

        1) Call by value
            Calling by value means passing the values of the args which are stored / copied into 
             the formal parameters of the func. Hence, the original values are unchanged, only the 
             parameters inside the function changes:

                #include<stdio.h>

                void plusTen(int x);

                int main()
                {
                    int x = 10;
                    plusTen(x);
                    printf("\nValue of x in main is %d", x);        /* prints 10 */
                    return 0;
                }

                void plusTen(int x)
                {
                    x = x+10;
                    printf("\nValue of x in plusTen is %d", x);    /* prints 20 */
                    return 0;
                }
            This passes the value of 'x' not 'x' itself, so x in unchanged. Only a copy of x is altered
             within the function. 
            To actually alter 'x', we would change:
                    plusTen(x);
            to:
                    x = plusTen(x); 


        2) Call be Reference
            In this style, we pass the address(reference) of a var as an arg to any func. When we pass the
             address, then the function will have access to our variable, as it would know where to save changes.

                #include<stdio.h>

                void plusTen(int *p);

                int main()
                {
                    int x = 10;
                    plusTen(&x);
                    printf("Value of x in %d", x);
                    return 0;
                }

                void calc(int *p)
                {
                    /*
                        changes the value directly and is stored in the var address
                    */

                    *p = *p + 10;
                }

- 19 How to pass Array to a function
    https://www.studytonight.com/c/array-in-function-in-c.php

    There are two ways to pass an array as argument(s) to a function:
        -either have an array as a parameter:
            int sum (int arr[]);
        -Or have a pointer in the params list, to hole the base addres of the array:
            int sum(int* ptr);

    Returning an Array from a function:
        We don't return arrays from funcitons, rather return a pointer holding the base address of the array to be returned.
        We must make sure the array exists after the function ends: i.e. the array is not local to the function.
            int* sum (int x[])
            {
                return x;
            }

    Passing arrays as params to a function
        Passing a single array element to a function:

            #include<stdio.h>

            void giveMeArray(int a);

            int main()
            {
                int myArray[] = { 2, 3, 4 };
                giveMeArray(myArray[2]);
                return 0;
            }

            void giveMeArray(int a)
            {
                printf(%d", a);
            }

        Passing a complete one-dimensional array to a function:
            #include<stdio.h>

            float findAverage(int marks[]);

            int main()
            {
                float avg;
                int marks[] = { 99, 90, 96, 93, 95 };
                avg = findAverage(marks);
                printf("Average marks = %.1f", avg);
                return 0;
            }

            float findAverage(int marks[])
            {
                int i, sum =0;
                float avg;
                for (i = 0; i <=4; i++) {
                    sum += marks[i];
                }
                avg = (sum / 5);
                return avg;
            }

        Passing a multi-dimensional array to a function:
            #include<stdio.h>

            void displayArray(int arr[3][3]);

            int main()
            {
                int arr[3][3], i, j;
                printf("Please enter 9 numbers for the array : \n");
                for (i = 0; i < 3; ++i)
                {
                    for (j = 0; j < 3; ++j)
                    {
                        scanf("%d", &arr[i][j]);
                    }
                }

                displayArray(arr);
                return 0;
            }

            void displayArray(int arr[3][3])
            {
                int i, j;
                printf("The complete array is: \n");
                for (i = 0; i < 3; ++i)
                {
                    printf("\n");ty
                    for (j = 0; j < 3; ++j)
                    {
                        printff("%d\t", &arr[i][j]);
                    }
                } 
            }
20 - C structures
    https://www.studytonight.com/c/structures-in-c.php

    A C structure (struct) is a user-defined datatype which allows us to combine data of different types together.
     Structures help to construct complex data types. It is similar to an array, though an array can only hold a 
     single data type.

    While an array can hold a list of student names, a structure can hold a variety of information about each student:
        name, age, grade, branch, address, etc.
    
    With structures, data is stored in the form or 'records'.

    'struct' keyword is used to define a structure:
      Note: the closing curly-bracket must be followed by a semi-colon.

        struct [structure name/tag]
        {
            //member var1
            //member var2
            //...
        }[structure_variables];

        struct Student
        {
            char name[25];
            int age;
            char branch[10];
            char sex;
        };

    To declare variables of type/structure "Student", you would specify:

        struct Student S1, S2

    Or you could simply specify the variables immediately after the closing curly bracket:

        struct Student
        {
            char name[25];
            int age;
            char branch[10];
            char sex;
        }S1, S2;   

    Though the first method is recommended.

    Accessing Structur Members:

    To access properties or "members" of a structure, you specify the name of the structure 
     variable with a period/ dot/ 'member access operator' appended with the property name 
      appended to that.

        #include<stdio.h>
        #include<string.h>

        struct Student
        {
            char name[25];
            int age;
            char branch[10];
            char sex;
        };

        int main()
        {
            struct Student s1;

            s1.age = 18;

            strcpy(s1.name, "Viraaj"); /* https://www.geeksforgeeks.org/strcpy-in-c-cpp/ */

            printf("Name of Student 1: %s", s1.name);
            printf("Age of Student 1: %d", s1.age);

            return 0;

        }
    
    'scanf()' can also be used to give values to structure members through terminal.

    Structures can be initialized at compile time:
    
        struct Patient
        {
            float height;
            int weight;
            int age;
        };

        struct Patient p1 = { 188.7, 55, 33 }; // initializations

    or afterwards:
        struct Patient p1;
        p1.height = 188.7;
        p1.weight = 55;
        p1.age = 33;

    Array of Structure:
        We can also declare an array of structure variables in which each element of the array will represent
         a structure variable.
            struct employee emp[5];
        The below example defines an array of 'emp' of size 5. Each element of the array 'emp' is of type 'Employee'.

            #include<stdio.h>

            struct Employee
            {
                char name[10];
                int sal;
            };

            struct Employee emp[5];
            int i, j;
            void ask()
            {
                for(i=0; i < 3; i++) 
                {
                    printf("\nEnter %dst Employee record: \n", i+1);
                    printf("\nEmployee name:\t");
                    scanf("%s", emp[i].name);
                    printf("\nEnter Salary:\t");
                    scanf("%d", &emp[i].sal);
                }
                printf("\nDisplaying Employee record:\n");
                for(i = 0; i < 3; i++)
                {
                    printf("Employee name is %s", emp[i].name);
                    printf("Salary is %d", emp[i].sal);
                }
            }

            void main()
            {
                ask();
            }

        Nested Structures:

            struct Student{
                char[30] name;
                int age;

                struct address
                {
                    char[50] locality;
                    char[50] city;
                    int pincode;
                }addr;
            };

        Structure as function arguments:
            #include<stdio.h>

            struct Student
            {
                char name[10];
                int roll;
            };

            void show(struct Student st);

            void main()
            {
                struct Student std;
                printf("\nEnter Student record:\n");
                printf("\nStudent name:\t");
                scanf("%s", std.name);
                printf("\nEnter Student rollno.:\t");
                scanf("%d", &std.roll);
                show(std);
            }

            void show(struct Student st)
            {
                printf("\nstudent name is %s", st.name);
                printf("\nroll is %d", st.roll);
            }

21 - typedef in C
    https://www.studytonight.com/c/typedef.php

    `typedef` is a keyword used in C to assign alternative names to existing datatypes. 
      Ususally used in user defined datatypes when the names become too complicated.

    Syntax:
        typedef <existing_name> <alias_name>;

    Example:
        typedef unsigned long ulong;
    
    The above defines a term `ulong` for an unsigned long datatype. Now `ulong` can be 
      used to define unsigned long type variables.
        ulong i, j;

    typedef can be used to give a name to user defined data:
        typedef struct
        {
            type member1;
            type member2;
            type member3;
        } type_name;
    
    Here, `type_name` represents the structure definition associated with it. Now it can
      be used to declare variables of this struct type:
        typen_name t1, t2;
    
    Example:
        #include<stdio.h>
        #include<string.h>

        typedef struct employee
        {
            char name[50];
            int salary;
        }emp;

        void main()
        {
            emp e1;
            printf("\nEnter Employee record:\n");
            printf("\nEmployee name:\t");
            scanf("%s", e1.name);
            printf("\nEnter Employee Salary:\t");
            scanf("%d", &e1.salary);
            printf("\nEmployee name is: %s", e1.name);
            printf("\nRoll is %d", e1.salary);
        }

    typedef can be used to give an alias name to pointers too.
        In Pointers * binds to the right, not the left
            int* x, y;

        This is declaring x as a pointer of type int whereas y will be declared as a plain int variable.
            typedef int* IntPtr;
            IntPtr x, y, z;
        
        But when we use `typedef` as we did above, we can declare any number of pointers in a single statement.

22 - C Unions
    https://www.studytonight.com/c/unions-in-c.php

    Unions are conceptually similar to structures. The suntax to declare/define a union is similar to that 
      of a structure. The only difference is in that of storage:
        -In structure, each member has its own storage location
        -In Union, uses a single shared memory location which is equal to the soze of it's largest data member

        struct Emp                  struct Emp
        {                           {
            char X; //size 1 byte       char X;
            char Y; //size 4 byte       char Y;
        } e;                        } e;

        struct              union
        X     Y            X    Y
     | |__| |__| |     | |________| |
     -------------     --------------
     ^ 5 bytes ^        ^ 4 bytes ^     


    This implies that while a union may contain many members of different types, it cannot handle 
      all the members at the same time.  

        union item
        {
            int m;
            float x;
            char c;
        }It1;

      This declares the var It1 of type union item. This union contains three memebers each with a different
      data type. However, only one of them can be used at a time. This is due to the fact that only one location
      is allocated for all the union variables, irrespective of their size. The compiler allocates the storage
      that is large enough to hole the largest var type.


      Example:
        #include<stdio.h>

        union item
        {
            int a;
            float b;
            char ch;
        };

        int main()
        {
            union item it;
            it.a = 12;
            it.b = 20.5;
            it.ch = 'v';

            printf("%d\n", it.a);
            printf("%f\n", it.b);
            printf("%c\n", it.ch);

            return 0;
        }

    Output:
        -26426
        20.1999
        v
    
    The values of a and b get corrupted but c was preserved. The only member whose value is currently stored will have 
      the memory.
    Since variable c was stored at last, the value of the other variables is lost.


23 - Intoduction to C pointers
    https://www.studytonight.com/c/pointers-in-c.php

    A pointer is a vairable which holds the address of another variable of some data type.

    Pointers are used to access memory and manipulate the address.

    They are one of the most distinct and exciting features of C.

    Address in C
        Whenever a variable is define, a memory location is assigned, in which it's value will be stored. We can easilty 
          check this memory address using the & symbol.
          If `var` is the name of the variable, then `&var` will give it's address.
          ex:
            #include<stdio.h>

            void main()
            {
                int var = 5;
                printf("Value of var is:", var);
                printf("Memory address of var is: %x\n", &var);
            }
                Outputs: Value of var is: 5; Memory address of var is: bcc7a00;
        
        This is also utilized in the function `scanf()`  ex: scanf("%d", &var);

        When a variable is declared, system allocates location/address to the variable in memory to hold the assigned value. 
        if the system has allocated memory location `90F` for a variable `a`
                  value
                |__10__|<-location in memory
                    a <- name of location
                    90F <- address

        We can access the value by using the variable name `a` or it's address `90F`
        The question is HOW can we access a variable using it's address? Since the memory addresses are also just numbers, 
          they can be assigned to some other variable. The variables which are used to hold memory address are called "Pointer Variables"
        A pointer variable is therefore nothing but a variable that holds an address of some other variable. And the value of a 
          pointer var gets stored in another memory location.
                addr of "a"
                |__90F__| -->pointer to --> |__10__| 
                    ptr < --pointer name        a
                    82C <-- address of pointer  90F

        -Pointers are more efficient in handling Arrays and Structures.
        -Pointers allow references to a function and thereby helps in passing a function as arg to other functions
        - Reduces length of the program and it's execution time.
        - Allows language to support Dynamic Memory management.
            Dynamic Memory Management - https://www.geeksforgeeks.org/what-is-dynamic-memory-allocation/
                 - the mechanism by which storage/memory/cells can be allocated during runtime

24 - Declaring, Initializing, and using a pointer var in C 
    https://www.studytonight.com/c/declaring-and-initializing-pointer.php
    
    The general syntax of pointer declaration is:
        datatype *pointer_name;
    
    the datatype of the pointer must be the same as the type of the variable which the pointer is pointing to. `void` type pointer 
      works but us not often used.

        int *ip;
        float *fp;
        double *dp;
        char *cp;

    Pointer initialization is the process of assigning the address of a var to a pointer var. Pointer var can only contain the address
      of a var of the same datatype. In C, the address operator `&` is used to determine the address of a var. 
      `&` immediately preceding a var returns the address of the var associated with it.
    
        #include<stdio.h>

        void main()
        {
            int a = 10;     // initialize a var;
            int *ptr;       // declare a pointer var;
            ptr = &a;       // initialize pointer var to first var address
        }
    
    Pointer vars always point to vars of same datatype.

        #include<stdio.h>

        int main()
        {
            float a;
            int *ptr;
            ptr = &a; // <-- ERROR - type mismatch
        }

    If you are uncertain which vars address to assign a pointer var when declaring it, it is recommended to assign a NULL val. 
      This is called a `NULL pointer`

        #include<stdio.h>

        int main()
        {
            int *ptr = NULL;
            return 0;
        }
is 
    Using the Pointer || Dereferencing of Pointer:
     Once a pointer has been assigned the address of a variable, to access the value of the variable, the pointer is `dereferenced`,
      using the `indirection operator` || `dereferencing operator` `*`

        #include<stdio.h>

        int main()
        {
            int a, *p;
            a = 10;
            p = &a;

            printf("%d", *p);       // prints the value of 'a';
            
            printf("%d", *&a);      // prints the value of 'a';

            printf("%u", &a);       // prints the address of 'a';

            printf("%u", p);        // prints the address of 'a';

            printf("%u", &p);       // prints the address of 'p';

            exit 0;
        }

    Points to remember:
        - While declaring/initializing the pointer variable, `*` indicates that the var is a pointer;
        - The addrss of any var is given be preceding the variable name with Ampersand `&`;
        - The pointer var stores the address of a var. The declaration `int *a` doesn't mean that 'a' is going to contain an integer value.
            It means that 'a' is going to contain the addrss of a variable storing an integer value;
        - To access the value aof a certain address stored by a pointer, `*` is used. `*` can be read as "value at";

    Example:

        #include<stdio.h>

        int main()
        {
            int i = 10;
            int *a;

            a = &i;

            printf("Address of a variable i is %u\n", a);

            printf("Value at the address, which is stored by pointer variable 'a', is: %d\n", *a);

            return 0;
        } 

25 - Pointer to a Pointer in C (Double Pointer)
    https://www.studytonight.com/c/pointer-to-pointer.php

    Pointers are used to store the address of other vars of same datatype. If you want to store
    the address of a pointer variable, you need another pointer to store it. When one pointer points 
    to the address of another pointer, it is known as `pointer to pointer` or a `double pointer`.

        int **p1;

    Two indirection operators `*` store and point to the address of the var. To store the address of THIS 
    pointer, the syntax would become:

        int ***p2;

    Example program:

        #include <stdio.h>

        int main()
        {
            int a = 10;
            int *p1;
            int **p2;

            p1 = &a;
            p2 = &p1;

            printf("The address of a is: %u\n", &a);
            printf("The address of p1 is: %u\n", &p1);
            printf("The address of p2 is: %u\n", &p2);

            printf("Value at the address stored by p2 = %u\n", *p2);
            printf("Value at the address stored by p1 = %d\n\n", *p1);
            printf("Value of **p2 = %d\n", **p2);

            return 0;
        }

    example output:
        Address of a = 2686724
        Address of p1 = 2686728
        Address of p2 = 2686732
        Value at the address stored by p2 = 2686724
        Value at the address stored by p1 = 10
        Value of **p2 = 10
    
    Address     2686732    ->   2686728     ->  2686724
    Value       2686728    ->   2686724     ->    10
    Variable       p2      ->      p1       ->     a

        -`p1` can only hold the address of variable `a` (based on the number of redirection operators)
            Similarly, `p2` can only hold the address of `p1`. It cannot hold the value of `a`
        -`*p2` gives us the value at an address stored by `p2`. `p2` stores the address of p1 and the 
            value of `p1` is the address of var `a`. Thus, `*p2` prints the value of `a`.
        - `**p2` can be read as `*(*p2)`. It gives the value stored at the address of `*p2`. From the 
            above statement, you know `*p2` means the address of `a`. Hence, the value at the address 
            `*p2` is 10; Thus, `**p2` prints 10.

26 - Pointer and Arrays in C
    https://www.studytonight.com/c/pointers-with-array.php

